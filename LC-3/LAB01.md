# LAB01 实验报告

### 核心思路

- 乘法的转换

  - LC3机器只能实现补码的加法指令。那么要进行乘法运算，必然要使用加法指令——即思路变为如何将乘法转换为加法。

  - 先观察一个例子

    > 3 * 5 = 3 + 3 + 3 + 3 + 3 = 5 + 5 + 5

    我们发现乘法可以按照最基本的定义拆分成若干个数相加，而这个“若干”则由其中一个数决定，被相加的数则由另一个数决定。即

    > 以5作为“若干” 3作为被加数 有3 * 5 = 3 + 3 + 3 + 3
    >
    > 以3作为“若干” 5作为被加数 有3 * 5 = 5 + 5 + 5

- 循环的控制

  - 使用机器码进行连加操作很简单：

    > 0001 111 000 0 00 000 ; R7 += R0, a simple example

  - 问题在于如何控制加的次数。对于连加的次数，可以在每进行一次加法操作之后使该次数减1，即“消耗一次”，最后该次数将会被消耗殆尽，即减小至0。

    > 0001 111 000 0 00 000 ;
    >
    > 0001 001 001 1 11111  ; R1 -= 1

  - 而为了判断该次数是否减小至0，我们可以使用bp指令，判断是否达到0——是，则停止循环；否，则继续循环。

    > 0001 111 000 0 00 000 ;
    >
    > 0001 001 001 1 11111  ;
    >
    > 0000 001 1 1111 1101  ; if still positive, go on

  - 如上，我们得到了核心思路与初版代码。

### L版本程序代码

- 初版

  - 在上述分析中我们只是简单地假定输入的乘数与被乘数都是正数（POSITIVE)，因此所设计的初版代码只是简单的对用于控制循环次数的乘数不断减1直至0为止——这显然是针对正数的。

  - 0的问题

    如下例子：

    > 5 * 0

    按照原有设计逻辑，此时得到最终结果为R7 = 5——这显然与预期不符。

  - 负数的问题

    首先我将最后的判定由非正改为非负（并没有更改自减一的逻辑）：

    > 0000 100 1 1111 1101  ; if still negative, go on

    然后运行如下例子：

    > 5 * (-1)

    运行结果如下：

    ![image-20211120154709225](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211120154709225.png)

    显然，所得到的值并不是-5的补码。

  - 解决方式

    不妨假定在核心程序指令的上一条是为R1赋初值。则我们可以加一条判断，判断用来计算循环数的R1的正负，抑或是0。

    - 若为0，直接跳转至停止。

    - 若为负，则将自减的循环改为自增。

      > 0001 001 001 1 00001 ; R1 += 1

    综合一下，得到如下代码：

    > 0000 010 0 00000100	; if zero, jump to halt
    > 0000 100 0 00000100	; if negative, jump to another loop
    > 0001 111 111 0 00 000  ; else, begin at R7 += R0
    > 0001 001 001 1 11111   ; R1 -= 1
    > 0000 001 1 11111101	; if still positive, go on
    > 1111 0000 00100101	 ; halt
    > 0001 111 111 0 00 000  ; (negative loop) R7 += R0
    > 0001 001 001 1 00001   ; R1 += 1
    > 0000 100 1 11111101	; if still negative, go on
    > 1001 111 111 111111    ; 对最终结果取反
    > 0001 111 111 1 00001   ; 并加一以对应
    > 1111 0000 00100101	 ; halt

    通过增加额外的判定，可以解决负数或0参与乘法的情况。

- 终版

  - 这样得到的代码能够完成目标，但是很冗长，**共11行**。对于乘数是正负的情况作了不同的循环操作，有没有可能使用相同的循环操作，以避免进行判断？

  - 注意到以下两点：

    - 任何一个n位二进制数通过自增i次可以得到本身，且i取决于末尾连续0的个数——若末尾有连续j个0，则i = 2 ^ (n - j)，即始终是2的倍数并且不大于2 ^ n；

    - 除此之外，一个n位二进制负数，假定其值为a，可以通过递减（-1）2 ^ n + a次得到0

      看一个例子：

      > 5  * (-1)

      在寄存器中表现为

      ![image-20211121103333583](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211121103333583.png)

      如果使用最初的循环，则经过 i = 2 ^ 16 - 1 次递减R1会达到0。而对于R0，由于R7是从0开始累加R1，自增2 ^ 16次之后一定会达到0，而自增2 ^ 16 - 1次代表少自增一次，可以看作**从0开始自减一次 **——即减5一次。

      换言之，如果将判定条件从最开始的仅正值更改为除0之外均持续循环，可以惊喜的发现对于负数仍然可以成功的进行运算：

      > 0000 101 1 11111101 ; if not zero, go on

      在寄存器中运行结果也的确如图：

      ![image-20211121104134806](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211121104134806.png)

      R7中储存的确乎是-5的补码。

  - 最终代码

    > 0001 111 111 0 00 000 ; R7 += R0
    >
    > 0001 001 001 1 11111  ; R1 -= 1
    >
    > 0000 101 1 11111101   ; if not zero, go on
    >
    > 1111 0000 00100101    ; halt

    **共3行**

## P版本程序代码

- 初版

  - 事实上L版本代码在进行负数乘法时进行了大量的额外自增：比如5 * （-1）原本只需进行一次自增，但是使用L版本代码则会额外执行2 ^ 16 - 2 次自增指令。那么在没有行数限制的情况下我们可以使用初版代码，额外增加数条判定，以略多的额外指令来避免执行负数乘法的大量额外非必要指令：

    > 0000 010 0 00000100	; if zero, jump to halt
    > 0000 100 0 00000100	; if negative, jump to another loop
    > 0001 111 111 0 00 000  ; else, begin at R7 += R0
    > 0001 001 001 1 11111   ; R1 -= 1
    > 0000 001 1 11111101	; if still positive, go on
    > 1111 0000 00100101	 ; halt
    > 0001 111 111 0 00 000  ; (negative loop) R7 += R0
    > 0001 001 001 1 00001   ; R1 += 1
    > 0000 100 1 11111101	; if still negative, go on
    > 1001 111 111 111111    ; 对最终结果取反
    > 0001 111 111 1 00001   ; 并加一以对应
    > 1111 0000 00100101	 ; halt

- 执行指令数计算

  - a * b

  | 执行的代码      | 为0  | 为正      | 为负          |
  | --------------- | ---- | --------- | ------------- |
  | 判断b           | 1    | +2        | +2            |
  | 不为0，进行自增 | /    | + 3 * b   | + 3 * \|b\|   |
  | b的正负         | /    | /         | + 2           |
  | 最终结果        | 1    | 2 + 3 * b | 4 + 3 * \|b\| |

​		但是可见，目前的复杂度是O(n)，在执行较大数的乘法时执行指令数将变得很大。应该有别的方法。

- 终版

  - 首先观察十进制的竖式乘法 3 * 25

    ```
    	 3
    *	25
    -------
    	15
    	6
    -------
    	75
    ```

    可以发现，并没有进行25次加法，而是只进行了两次加法一次移位。同样，255则是三次加法两次移位，诸如此类。那么，二进制和十进制之间只是进制上的区别，相应的算法完全可以应用于二进制乘法。而对于二进制，我们可以通过自加来做到右移。

  - 初始化

    > 0101 111 111 1 00000 ; CLEAR R7
    >
    > 0001 010 111 1 00001 ; R2用于检查R1中的乘数每一位是否是1，即是否需要进行一次加法操作

  - 检验当前位置是否有1

    > 0101 011 000  0 00 010 ; 将结果放入R3，若当前位置有1则为1，若当前位置为0，则为0，继续换下一位置检验
    >
    > 0000 010 0 0000 0001 ; 若为0，跳转到直接移位，否则进行一次加法操作再移位

  - 进行循环

    > 0001 111 111 0 00 000 ;  R7 = R7 + R0
    >
    > 0001 000 000 0 00 000 ; R0移位
    >
    > 0001 010 010 0 00 010 ; R2移位，用于检查下一位

  - 循环结束

    > 0000 010 0 0000 0001 ; 若为0，即自增到最后一位，则停止
    >
    > 0000 111 1 1111 1001 ; 否则无条件继续循环
    >
    > 1111 000 00100101 ; HALT

  - 同样，对于负数的运算，由L版代码的分析可知，可以同样得到需要的结果。

- 执行指令数计算

  - 对于任意的乘数与被乘数，最多执行

    > 2 + 7 * 16 - 1 = 113

  - 最少执行

    > 2 + 6 * 16 - 1 = 97

    与乘数被乘数的大小无关，只针对位数进行运算。由此，我们得到满足P版本的代码。

## 实验总结

- 领会到补码运算的巧妙之处，对于减法可以转换为若干次加法；
- 能够使用机器码编写一些简单的条件判断语句，实现一些基本思路；
- 能够较熟练使用LC3tool；
- 能够根据机器码粗略的推断指令数。