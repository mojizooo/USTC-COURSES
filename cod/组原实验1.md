<center><font face="宋体" size=5 weight=xx><b>中国科学技术大学计算机学院</b></font></center>

<center><font face="宋体" size=5><b>《计算机组成原理实验报告》</b></font></center>





![image-20211104134534049](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211104134534049.png)





<center><font size=5 face="宋体">实验题目：运算器及其应用</font></center>

<center><font size=5 face="宋体">学生姓名：林宸昊</font></center>

<center><font face="宋体" size=5>学生学号：PB20000034</font></center>

<center><font face="宋体" size=5>完成日期：2022.3.15</font></center>



## 【实验题目】运算器及其应用

## 【实验目的】 设计并实现ALU，并在后续中能够利用前述ALU进行复杂设计

## 【实验平台】 VIVADO FPGAOL

## 【实验内容】

### 【一：ALU模块的逻辑设计与仿真】

- 数据通路：

  ![image-20220315182214513](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315182214513.png)

- 状态图：

  ![image-20220315182238581](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315182238581.png)

- 编写设计文件：

  ```verilog
  module alu_32(
      input [31:0] a, b,
      input [2:0] f,
      output reg [31:0] y,
      output reg z
      );
      always@(*)
      begin  
          case(f)		//通过case语句实现操作功能的选择
          3'b000: 
              y = a + b;
          3'b001:
              y = a - b;
          3'b010:
              y = a & b;
          3'b011:
              y = a | b;
          3'b100:
              y = a ^ b;
          default:
              begin
                  y = 0;
                  z = 1;
              end
          endcase
  	end
  endmodule
  ```

- 仿真文件

  ```verilog
  module sim1(
  
      );
      reg [31:0] a,b;
      reg [2:0] f;
      wire [31:0] y;
      wire z;			//输出必须是线网型
      alu_32 alu(a, b, f, y, z);
      initial
      begin
          a = 32'h8; b = 32'h2; 
          f = 3'b0; #20 f = 3'b1; #20 f = 3'b010; #20 f = 3'b011; 
          #20 f = 3'b100; #20 f = 3'b111; #20 $finish;
      end
  endmodule
  ```

- 仿真图象

  ![image-20220315182840338](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315182840338.png)

### 【二：性能报告】

- 生成电路

  - RTL电路：

    ![image-20220315183146814](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183146814.png)

  - 综合电路：

    ![image-20220315183343262](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183343262.png)

  

- 资源使用情况

  ![image-20220315183453899](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183453899.png)

  

- 综合电路性能(由于32位ALU未烧在板子上故不做时间性能的特定分析)

  ![image-20220315183603404](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183603404.png)

### 【三：6位ALU】

- 数据通路

  ![image-20220315183753572](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183753572.png)

- 状态图（真值表）

- ![image-20220315183830886](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183830886.png)

- 端口分配

  ![image-20220315183857084](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220315183857084.png)

- 设计文件

  ```verilog
  module alu_6(
      input clk,
      input en,
      input [1:0] sel,
      input [5:0] x,
      output reg [5:0] y,
      output reg z
      );
      reg [2:0] f;
      reg [5:0] a, b;
      always@(posedge clk)
      begin
          if(en)
          case(sel)
          2'b00:a <= x;
          2'b01:b <= x;
          2'b10:f <= x[2:0];
          endcase
      end
      
      always@(posedge clk)
      begin
          case(f)
          3'b000: 
              y <= a + b;
          3'b001:
              y <= a - b;
          3'b010:
              y <= a & b;
          3'b011:
              y <= a | b;
          3'b100:
              y <= a ^ b;
          default:
              begin
                  y <= 0;
                  z <= 1;
              end
          endcase
      end
  endmodule
  ```

- 约束文件

  ![image-20220323202824568](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220323202824568.png)

  ![img](file:///C:\Users\lenovo\Documents\Tencent Files\1794027676\Image\C2C\~51KSF~}3GVT[P78]7QO@TC.png)

- FPGA运行结果（设a = 1, b = 3)

  ![image-20220317190108622](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190108622.png)

  ![image-20220317190129634](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190129634.png)

  - 测试与功能（f赋值010）

    ![image-20220317190203778](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190203778.png)

- RTL电路图

  ![image-20220316162538026](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316162538026.png)

- 资源使用情况

  ![image-20220316162703179](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316162703179.png)

  ![image-20220316162718477](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316162718477.png)

- 综合电路时间性能（

  ![image-20220317190256370](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190256370.png)
  
  ![image-20220317190308558](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190308558.png)
  
  slack为正即满足setup time/hold time需求，high fanout为模块直接调用下级模块数量，其后则为各线路时间延迟。

### 【四：FLS】

- 数据通路

  ![image-20220316170518425](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316170518425.png)

  与后续得到的RTL电路比较大致一致

  ![image-20220316170554712](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316170554712.png)

- 状态图

  ![image-20220316171221339](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316171221339.png)

- 设计文件

  ```verilog
  //信号模块用于取按钮边沿
  module signal(
      input clk,button,
      output button_edge
  );
      reg b1, b2;
      always@(posedge clk)
      	b1 <= button;
      always @ (posedge clk)
      	b2 <= b1;
      assign button_edge = b1 & (~b2);
  endmodule
  
  module fls(
      input clk, rst,
      input en,
      input [6:0] d,
      output reg [6:0] f
      );
      reg [6:0] d0, d1; //用于临时储存结果
      reg [1:0] cs;	//共四个状态，故只需两位
      reg [1:0] ns;
      wire b_edge;	//按钮边沿
      signal signal(clk, en, b_edge);
      
      //next state
      always @ (*)
      begin
          case(cs)
              2'b00: ns = 2'b01;
              2'b01: ns = 2'b10;
              2'b10: ns = 2'b11;//转入状态二后即进行序列输出，在两个状态间来回切换
              2'b11: ns = 2'b10;
          endcase
      end
      
      //how current state change
      always @ (posedge clk or posedge rst)
      	if(rst)
      		cs <= 2'b00;
      	else if(b_edge)
      		cs <= ns;
      
  	//output 
      always @ (posedge clk or posedge rst)
      begin
          if(rst)
          begin
              d0 <= 0;
              d1 <= 0;
          end
              
          else if(b_edge)
              case(cs)
                  2'b00://状态零，赋值给f0
                  begin
                      d0 <= d;
                  end
                  2'b01://状态一，赋值给f1
                  begin
                      d1 <= d;
                  end
                  2'b10://状态二，此时d0排序靠后，累加至d0
                  begin
                      d0 <= d1 + d0;
                  end
                  2'b11://状态三，此时d1排序靠后，累加至d1
                  begin
                      d1 <= d1 + d0;
                  end
                  endcase
      end
      
      always @ (posedge clk or posedge rst)
      begin
      if(rst)
          f <= 0;
      else
       	case(cs)
              2'b00:
              begin
                  f <= d;
              end
              2'b01:
              begin
                  f <= d;
              end
              2'b10:
              begin
                  f <= d0;
              end
              2'b11:
              begin
                  f <= d1;
              end
          endcase
      end
  endmodule
  ```

- 仿真文件

  ```verilog
  module sim1(
  
      );
      reg clk, rst, en;
      reg [6:0] d;
      wire [6:0] f;
      fls fls(clk, rst, en, d, f);
      initial 
      begin 
      rst = 0;
      #4 rst = 1;
      #4 rst = 0;
      end
      initial clk = 0;
      always #1 clk = ~clk;
      initial en = 0;
      always #5 en = ~en;
      initial
      begin
          d = 1;#20 d = 2;
          end
  endmodule
  ```

- 仿真结果

  ![image-20220316172413548](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220316172413548.png)

  可见在输入初始的两项之后f按照斐波那契序列输出。

- FPGA测试结果

  - 输入a = 1, b = 2

    ![image-20220317190520047](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190520047.png)

    ![image-20220317190547088](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190547088.png)

  - 此后每一次均输出斐波那契的下一项

    ![image-20220317190938652](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190938652.png)

    ![image-20220317190952662](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220317190952662.png)

## 【总结与思考】

- 实验总结
  - 总体来说难度不高，主要用于复习上学期所学的模电实验内容——尤其是三段式有限状态机，以及学习如何对当前电路性能进行查看和评测；

- 实验建议（吐槽）
  - 作为一个复习模电的实验感觉没啥问题，确实花了蛮久复习代码怎么写（比如取边沿），但是画数据通路略有些折磨。

