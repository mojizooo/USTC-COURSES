<center><font face="宋体" size=5 weight=xx><b>中国科学技术大学计算机学院</b></font></center>

<center><font face="宋体" size=5><b>《计算机组成原理实验报告》</b></font></center>





![image-20211104134534049](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211104134534049.png)



<center><font size=5 face="宋体">学生姓名：林宸昊</font></center>

<center><font face="宋体" size=5>学生学号：PB20000034</font></center>

<center><font face="宋体" size=5>实验日期：2022.3.29</font></center>




## 【实验题目】寄存器堆与存储器及其应用

## 【实验目的】

- 能够自行描述寄存器堆并进行仿真与应用；
- 能够例化存储器IP核并进行仿真与应用；
- 能够设计与实现FIFO队列结构。

## 【实验平台】Vivado、FPGAOL

## 【实验步骤】

### 【一、寄存器堆仿真】

- 设计文件

  ```verilog
  module RF1(
      input clk,
      input [4:0] ra0,
      input [4:0] ra1,
      input [4:0] wa,
      input we,
      input [31:0] wd,
      output [31:0] rd0,
      output [31:0] rd1
  );
      reg [31:0] regfile[4:0];
      assign rd0 = regfile[ra0];
      assign rd1 = regfile[ra1];
      
      always @ (posedge clk)
      begin
      	if(we) regfile[wa] <= wd;
      end
  endmodule
  ```

- 仿真文件

  ```verilog
  module RF_SIM(
      );
      reg clk;
      reg [4:0] ra0;
      reg [4:0] ra1;
      reg [4:0] wa;
      reg we;
      reg [31:0] wd;
      wire [31:0] rd0;
      wire [31:0] rd1;
      RF1 RR(clk, ra0, ra1, wa, we, wd, rd0, rd1);
      initial clk = 1;
      always #5 clk = ~clk;
      initial 
      begin
      	ra0 = 0;
      	ra1 = 1;
      	wa = 0;
      	wd = 10;
      	we = 0; #10 we = 1;
      	#10 wa = 1;
      	#10 $finish;
      end
  endmodule
  ```

- 仿真结果

  ![image-20220329155645038](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155645038.png)

### 【二、IP例化存储器】

- 块式存储器例化（分布式类似）

  ![image-20220329155829601](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155829601.png)

  ![image-20220329155844513](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155844513.png)

  ![image-20220329155916336](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155916336.png)

  ![image-20220329155940895](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155940895.png)

  ![image-20220329155956807](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329155956807.png)

- 仿真文件

  ```verilog
  module IP_sim(
      );
      reg [7:0] dina;
      reg we;
      reg [3:0] addra;
      reg clka;
      reg ena;
      wire [7:0] douta_blk;	//块式存储器输出
      wire [7:0] douta_dist;	//分布式存储器输出
      blk_mem_gen_0 blk1(.addra(addra), 
                         .clka(clka),
                         .dina(dina),
                         .douta(douta_blk),
                         .ena(ena),
                         .wea(we));
      dist_mem_gen_0 dist1(.a(addra),
                           .d(dina),
                           .clk(clka),
                           .we(we),
                           .spo(douta_dist));
      initial clka = 0;
      always #5 clka = ~clka;
      initial 
      begin
      	ena = 1; we = 0;
      	#10 we = 1; dina = 10;
      	#10 dina = 5;
      	#10 we = 0; dina = 15;
      end      
      initial 
      begin
      	#3 addra = 1;
      	#7 addra = 2;
      	#10 addra = 3;
      	#10 addra = 4;
      end             
  endmodule
  ```

- 仿真结果

  - Read First

    ![image-20220329160519513](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329160519513.png)

  - Write First

    ![image-20220329160627546](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329160627546.png)

  - No Change

    ![image-20220329160818974](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329160818974.png)
  
- 可以发现，块式存储器拥有三种读写模式而分布式并没有；分布式存储器的读出与时钟信号无关，只要地址改变就会改变输出的值，属于异步，而块式是同步。

### 【三、FIFO队列实现】

- 数据通路及控制器

  ![image-20220329191021619](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329191021619.png)
  其中RF已由上述步骤描述，SDU模块仅涉及hexplay的输出，主要设计LCU模块。

  - LCU（大致数据通路）

    ![image-20220329192205178](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329192205178.png)

- 状态图

  ![image-20220329192417584](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329192417584.png)

- 设计文件

  ```verilog
  module signal(	//取信号边沿
      input clk,button,
      output button_edge);
      reg b1, b2;
      always@(posedge clk)
      b1 <= button;
      always @ (posedge clk)
      b2 <= b1;
      assign button_edge = b1 & (~b2);
  endmodule
  
  module sync(	//二级同步模块（也可不使用）
      input clk,
      input s_src,
      output reg s_dst
      );
      reg meta;
      always @ (posedge clk)
      begin
          meta <= s_src;
          s_dst <= meta;
      end
  endmodule
  
  module FIFO(
      input clk, rst,
      input enq,
      input [3:0] in,
      input deq,
      output reg [2:0] an,
      output reg [3:0] seg,
      output reg [7:0] led
      ); 
      
      wire e_edge, d_edge;//信号边沿
      wire e_dst, d_dst;	//二级同步信号
      reg full = 0;		//队满标志
      reg emp = 1;		//队空标志
      signal edge1(clk, enq, e_edge);
      signal edge2(clk, deq, d_edge);
      sync sy1(clk, e_edge, e_dst);
      sync sy2(clk, d_edge, d_dst);
      reg [1:0] cs;		//当前状态
      reg [1:0] ns;		//接续状态
      parameter IDLE = 2'b00;//空闲状态
      parameter DEQU = 2'b01;//出队状态
      parameter ENQU = 2'b10;//入队状态
      
      reg [2:0] head = 0;		//队头
      reg [2:0] tail = 0;		//队尾
      reg [3:0] out;
      reg [7:0] valid = 0;	//判空标志数组
      reg [3:0] regfile[7:0]; //实际用于存储的寄存器堆
      
      always @ (*)
      begin
          case(cs)
              IDLE:
              begin
                  if(e_dst && !full)		//入队按钮有效且非满
                      ns = ENQU;
                  else if(d_dst && !emp)	//出队按钮有效且非空
                      ns = DEQU;
                  else ns = IDLE;
              end
              DEQU:
              begin
                  if(e_dst && !full)
                      ns = ENQU;
                  else if(d_dst && !emp)
                      ns = DEQU;
                  else ns = IDLE;
              end 
              ENQU:
              begin
                  if(e_dst && !full)
                      ns = ENQU;
                  else if(d_dst && !emp)
                      ns = DEQU;
                  else ns = IDLE;
              end
          endcase
      end
      
      //LCU & RF
      always @ (posedge clk or posedge rst)
      begin
          if(rst)
              cs <= IDLE;
          else 
              cs <= ns;
      end
      
      always @ (posedge clk or posedge rst)
      begin
          if(rst)
          begin
              valid <= 0;
              full <= 0;
              emp <= 1;
          end
          else
              case(cs)
                  ENQU:
                  begin
                      regfile[tail] <= in;	//输入
                      valid[tail] <= 1;		//将当前位置标记为非空
                      tail <= (tail + 1);		//队尾进一
                      full <= ((tail + 1 == 8)||(tail + 1 == head));
                      emp <= 0;
                  end
                  DEQU:
                  begin
                      out <= regfile[head];	//输出
                      valid[head] <= 0;		//将当前位置标记为空
                      head <= head + 1;		//队头进一
                      emp <= ( (head + 1 == 8) || (head + 1 == tail));
                      full <= 0;
                  end
              endcase
          end
      //SDU 利用高频闪烁达到同时显示效果
      always @ (posedge clk)
      begin
          led[7] <= full;
          led[6] <= emp;
          led[3:0] <= out;
      end
      
      reg [9:0] cnt;
     
      always @ (posedge clk)
      begin
          if(cnt >= 10'd800)
              cnt <= 0;
          else
              cnt <= cnt + 1;
          if(valid == 0)
              begin
                  an <= 0;
                  seg <= 0;
              end            
          else if(cnt <= 10'd100)
          begin
              if(valid[0])
              begin
                  an <= 0;
                  seg <= regfile[0];
              end
          end
          else if(cnt <= 10'd200)
          begin
              if(valid[1])
              begin
                  an <= 1;
                  seg <= regfile[1];
              end
          end
          else if(cnt <= 10'd300)
          begin
              if(valid[2])
              begin
                  an <= 2;
                  seg <= regfile[2];
              end
          end        
          else if(cnt <= 10'd400)
          begin
              if(valid[3])
              begin
                  an <= 3;
                  seg <= regfile[3];
              end
          end
          else if(cnt <= 10'd500)
          begin
              if(valid[4])
              begin
                  an <= 4;
                  seg <= regfile[4];
              end
          end
          else if(cnt <= 10'd600)
          begin
              if(valid[5])
              begin
                  an <= 5;
                  seg <= regfile[5];
              end
          end
          else if(cnt <= 10'd700)
          begin
              if(valid[6])
              begin
                  an <= 6;
                  seg <= regfile[6];
              end
          end
          else
          begin
              if(valid[7])
              begin
                  an <= 7;
                  seg <= regfile[7];
              end
          end
      end             
  endmodule
  
  ```

- 仿真文件

  ```verilog
  module fifo_sim(
      );
      reg clk, rst;
      reg enq;
      reg [3:0] in;
      reg deq;
      wire [2:0] an;
      wire [3:0] seg;
      wire [7:0] led;
      FIFO fifo(clk, rst, enq, in, deq, an, seg, led);
      initial clk = 0;
      always #1 clk = ~clk;
      initial begin
      rst = 0;#1 rst = 1;#1 rst = 0;
      end
      initial 
      begin
      enq = 1;#5 enq = 0;in = 1;#5 enq = 1;#5 enq = 0;#5 enq = 1;in = 3;#5 enq = 0;#5 enq = 1;in = 4;#5 enq = 0;#5 enq = 1;in = 5;#5 enq = 0;
      #5 enq = 1;in = 5;#5 enq = 0;#5 enq = 1;in = 5;#5 enq = 0;#5 enq = 1;in = 5;#5 enq = 0;#5 enq = 1;in = 5;#5 enq = 0;
      #5 deq = 1;#5 deq = 0;#5 deq = 1;#5 deq = 0;#5 deq = 1;#5 deq = 0;#5 deq = 1;#5 deq = 0;#5 $finish;
      end
  endmodule
  ```

- 仿真结果

  ![image-20220329163532911](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163532911.png)

- 约束文件

  ![image-20220329163723764](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163723764.png)

  ![image-20220329163735098](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163735098.png)

  

- 烧写结果

  - 初始状态

    ![image-20220329163641934](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163641934.png)

  - 写入至队满

    ![image-20220329163828824](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163828824.png)

  - 输出至队空

    ![image-20220329163913560](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163913560.png)

    ![image-20220329163930643](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329163930643.png)

## 【总结与思考】

- 实验总结
  - 事实上上学期数电实验已使用过IP核，但仅例化了分布式，较为简单。本次实验通过例化块式与分布式存储器了解二者的本质区别所在，并能够改变读写模式进行写入或输出；
  - 学会设计FIFO队列，其实本质还是复习数电实验（包括时分复用），难度中等（对没有基础而言），毕竟PPT其实已经给出了较为详细的说明。
- 实验建议
  - 如果实验文档能更详细一点就好了；
  - 要是实验文档能更详细一点就好了；
  - 真的实验文档能更详细一点就好了。







