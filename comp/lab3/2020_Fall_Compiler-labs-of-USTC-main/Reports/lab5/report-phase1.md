# Lab5 实验报告-阶段一

<p align=right>吕瑞 PB18111707 谭泽霖 PB18010454 艾语晨 PB18000227</p>

## 实验要求

阅读`Mem2Reg`与`LoopSearch`两个优化Pass的代码，能够描述优化的基本流程，并且回答思考题。



## 思考题

### LoopSearch

1. **循环的入口如何确定？循环的入口的数量可能超过1嘛？**

答：

（1）循环入口的确定通过函数 `find_loop_base` 实现：

- 输入一个 Tarjan 算法获得的强连通分量，以及一个保存 base 已获得的外层循环的入口块集合；

- 输出当前强连通分量中，未获取到 base 的最外层循环的入口块；

1. 初始化 `base = nullptr;`

2. 遍历强连通分量的结点，对其中的每一个结点（基本块），当该块的一个前驱不在该强连通分量中，说明该块是当前强连通分量中最外层循环的入口块`base`；

3. 如果 `base` 不为空，说明已经获取到目标值，直接返回；

4. 如果 `base` 为空，说明当前强连通分量中所有块的前驱都在强连通分量中，也说明当前的循环是嵌套在另一个更大的循环里的，大循环的入口块前驱后继都被删除了，所以在当前循环中找不到一个块的前驱在循环外部。

    此时需要用到 `reserved` ：

```c
for (auto res : reserved)
{ // 大循环已经获取 base，向内获取小循环的 base
  // res 是已经找到 base 的循环入口结点
   for (auto succ : res->succs)
   {
       if (set->find(succ) != set->end())
       { // 如果当前 res 的一个后继在强连通分量集 set（小循环） 中，则这个后继块就是下一个小循环的入口块
           base = succ;
       }
   }
}
```

（2）循环入口的数量取决于生成的 IR，LoopSearch 基于现有的 IR 去找。

根据 lab4 中 cminusf 语法的 IR 生成规则，每个循环都有且只有一个入口，这个入口就是包含进入循环的判断语句的基本块 (basebb)。

这是因为在 cminusf 语法中，不存在 goto(L) 语句，也就是说，不在 basebb 中，但却能直接跳转入循环内部的语句是不存在的。因此循环的入口块唯一。

故而在 `LoopSearch.hpp` 中对成员函数 `get_loop_base` 函数的定义为：

```c++
// std::unordered_map<BBset_t *, BasicBlock *> loop2base; // 循环-循环入口块
BasicBlock* get_loop_base(BBset_t *loop) { return loop2base[loop]; }
```

这也表明循环入口的数量不能超过 1。

2. **简述一下算法怎么解决循环嵌套的情况。**

答：

（1）维护一个辅助数组 `reserved` 来保存当前程序中已经找到 base 的循环的循环入口块；

（2）利用强连通分量算法找出图中所有的强连通分量存在 `scss` 中，每一个强连通分量都代表程序中的一个最外层循环；

（3）遍历 `scss` 中的成员，利用 `find_loop_base` 算法寻找当前强连通分量中，最外层循环的入口块，入口块的值赋给 `base`；转（4）

（4）保存 `loop_set/fun2loop/base2loop` 等信息后，将当前 base 插入 `reserved` 中，表示该入口块对应的循环已经被处理过；

同时删除 base 块的前驱块指向 base 的后继 & 后继块指向 base 的前驱，目的也是标识出该入口块对应的循环已经被处理过，以便在 `find_loop_base` 函数（具体实现方式见`思考题 1.`）中，作为向内查找小循环的判断依据。同时也破坏了 base 所在循环的完整性，使得图中的强连通分量数 ``-1`；转（5）

（5）遍历 `scss` 结束之后，重置 `scss` 和 图中结点的遍历信息，重复（2）直到图中没有强连通分量；

此时找出来的强连通分量中的结点并不会发生变化，但每次都会更新 `reserved` 数组，事实上，每重找一次强连通分量，都是在向内找一层循环的入口块。

### Mem2reg

1. **请简述支配边界的概念。**

    答：将相对于 n 具有如下性质的结点 m 的集合称为 n 的支配边界，记为 `DF(n)`：

    （1）n 支配 m 的一个前驱；

    （2）n 并不严格支配 m。

    > **严格支配性：** 当且仅当 $a \in DOM(b)-\{b\}$ 时，a 严格支配 b；

    非正式的，`DF(n)` 包含：在离开 n 的每条 CFG 路径上，从结点 n 可达但不支配的第一个结点。

2. **请简述`phi`节点的概念，与其存在的意义。**

    答：
    1. phi节点是用于根据当前块的前导选择值的指令，为选择语句之后的语句选出来正确的分支中的值

    2. phi结点可以为后续指令选择变量的正确版本，在某些情况下，它可以帮助避免不必要的加载。

        举个例子：在一个程序中，同一变量可能在不同的控制流路径上都有定值，例如，源程序

        ```c
        if(flag) x = -1; else x = 1;
        y = x*a;
        ```

        有定值 x 的来那个通不同控制流路径。在 SSA 中给这两个分支中的 x 使用不同的名字，而 `phi` 函数就是用来确定在 `y=x*a` 处，x 应该使用哪个名字的变量值。

        ```c
        if(flag) x1 = -1; else x2 = 1;
        x3 = phi(x1,x2); // phi(x1,x2) 返回某个变元的值，取决于到达 phi 时所通过的控制流路径
        y = x3*a;
        ```



3. **请描述`Mem2Reg Pass`执行前后的`ir`的变化, 简述一下**。

    答：
    1. 去掉了在函数调用前部对函数参数的存储和再读取语句，而是直接使用函数参数寄存器
    2. 对于调用函数的返回值，也没有额外分配寄存器来存储，而是直接使用了返回寄存器
    3. 在 main 函数需要从分支语句中调用所需要的变量版本时，使用了 phi 语句，来在两个分支之间进行选择

    

4. **在放置 phi 节点的时候，算法是如何利用支配树的信息的？**

    答：

    （1）对于每一个跨block的全局变量$R_x$，我们同时使用支配树和CFG找到他的支配边界，对属于该支配边界的每一个节点，插入$R_x$所需要的$\Phi$函数算法。

    （2）实现层面：

    1. 遍历CFG中的每一个结点$A$，如果该结点有至少两个前驱，则对$A$的每个前驱结点$A_{pre}$进行遍历。

    2. 如果$A_{pre}$不是A的直接支配结点(IDOM(A))，则将该结点加入A的支配边界
    3. $A_{pre}$等于沿着$A_{pre}$的直接支配结点向上遍历
    4. 循环执行2，3直到$A_{pre}$是A的直接支配结点

5. **算法是如何选择 `value` (变量最新的值)来替换`load`指令的？（描述数据结构与维护方法）**

    答：

    （1）维护一个 map 栈 –  `std::map<Value *, std::vector<Value *>> var_val_stack;` 表示跨越多个程序块的活动变量名（基本名 – value）和每个基本名在不同控制流路径上的重命名变量的集合 `vectot<Value>`。

    （2）对于一个语句块`bb`，首先执行语句块中的 `phi` 函数，将最新的 `value` 值存入 `var_val_stack[l_val]` 的末尾；

    （3）接下来，对于 `bb` 中的 `load` 指令，如果 `instr->getlval()` 的值已经出现在当前的寄存器中，则用最新的 `value` 值来替换 load 指令，即，该load 指令冗余。

    其中，最新的 `value` 值即为`var_val_stack[l_val]`的栈顶元素值。

    ```c
    if ( var_val_stack.find(l_val) != var_val_stack.end()){
        instr->replace_all_use_with(var_val_stack[l_val].back());
        wait_delete.push_back(instr);
    }
    ```



### 代码阅读总结

#### LoopSearch 部分

循环查找 – 分析类 Pass，用来为之后的优化 pass 获取 CFG 的必要信息，不改变 CFG 本身；

**目的是找到程序当中的所有循环，以及这些循环的入口块（即循环的条件块）等信息**，是后续的循环不变式外提优化的基础；

（1）利用 `Tarjan` 算法获得有向图中的强连通分量是查找循环的基础；

（2）根据 lab4 中 cminusf 语法的 IR 生成规则，每个循环都有且只有一个入口，这个入口就是包含进入循环的判断语句的基本块 (basebb)。

这是因为在 cminusf 语法中，不存在 goto(L) 语句，也就是说，不在 basebb 中，但却能直接跳转入循环内部的语句是不存在的。因此循环的入口块唯一。

（3）维护一个辅助数组 `reserved` 来保存当前程序中已经找到 base 的循环的循环入口块，在`find_loop_base`函数中，便于寻找嵌套循环的入口；

（4）所有的循环都是自外向内遍历寻找循环入口块。

#### Mem2Reg 部分

众所周知LLVM IR其实在clang的codegen后并不是strict-SSA结构，因为这时候局部变量表现为alloca指令，同时对局部变量通过load和store进行读写操作，这会导致局部变量可能会存在多个def(多个store指令)，而SSA要求每个变量只能有一个def。这时LLVM会通过标准的SSA构造算法来将原始IR转换成minimal-SSA并最终转换成prune-SSA，这一切都在mem2reg的pass中实现。

mem2reg pass 的经过是：

1. 利用CFG生成支配树，利用在这二者中蕴涵着的支配关系，插入块所需要的$\Phi$函数。
2. 下一个环节，rename。重命名实际上是一个删除多余的load和store指令的过程，由于SSA本身的限制，对于gep，即针对数组或结构体的操作不做处理；而全局变量由于在每一个块中都需要有不同的实例，也不需要处理。

通过对三个部分（Loop_Search、Mem2Reg、Dominators）的源码进行阅读和分析，辅以相应资料，我们对LLVM IR依据SSA的标准进行的优化机理与流程有了初步的认识，为后续的设计进行了良好的铺垫

### 实验反馈 （可选 不会评分）

对本次实验的建议

### 组间交流 （可选）

本次实验和哪些组（记录组长学号）交流了哪一部分信息