## OS HW4

### 1.

1. segmentation fault
   - 又称存储器段错误，也称访问权限冲突，是一种程序错误；
   - 它一般出现在程序企图访问CPU无法定址的存储器区块时。通常该错误是由于调用一个地址而该地址为空所造成的，数组访问越界也可能产生这个错误。
2. TLB: Translation Look-aside Buffer
   - 专用的、小的、查找快速的高速硬件缓存，称为**转换表缓冲区**；
   - 作为关联的高速内存用于降低从虚拟地址到真实物理地址的访问时间。
3. Page Fault:
   - 即**页缺失**，是指当软件试图访问已映射在虚拟空间中，但是并未加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断；
   - 当访问的内存不在虚拟地址空间时也会发生page fault；
   - 事实上这并不一定就是一种错误，而是一种解决问题的机制，便于系统分配所需的物理空间。
4. Demand paging：
   - 即**请求调页**，指当进程申请空间时，只有虚拟地址被分配给它，真实物理地址并未被分配；
   - 当发生页面访问请求时，系统通过page fault分配真实物理页面。

### 2. thrashing：抖动

- 当一个进程没有需要支持活动使用页面的帧数，它将很快产生缺页错误。此时必须置换某个页面，但是由于所有页面都在使用中，必须立即置换需要再次使用的页面，因此会再次快速产生缺页错误。这种高度的页面调度活动称为**抖动**。
- 当多道程度过高且频繁使用全局置换算法时易出现**抖动**。

### 3.

1. **100ns**。50ns用于访问页表，50ns用于访问内存数据；

2. **64.5ns**。

   ```
   0.75 * (50 for accessing data + 2 for accessing TLB) + 
   0.25 * (2 for accessing TLB + 50 for accessing page table + 50 fot accessing data)
   = 64.5ns
   ```

### 4.

- TLB miss with no page fault
  - 页表在内存中但是页码不在TLB中；
- TLB miss and page fault
  - 页表不在内存中并且页码不在TLB中；
- TLB hit and no page fault
  - 页表在内存中并且页码也在TLB中；
- TLB hit and page fault
  - 不会发生。如果TLB中命中，就说明页码在TLB中，则内存中必有对应的页表。

### 5.

- 设page fault rate 为p，则有

  ```
  	(1 - p) * 100ns + 0.3 * p * 8ms + 0.7 * p * 2oms <= 200ns
  =>	p <= 6.09756 * 10 ^ -6 此即p的范围
  ```

### 6.

- LRU

  | 7    | 2    | 3    | 1    | 2    | 5    | 3    | 4    | 6    | 7    | 7    | 1    | 0    | 5    | 4    | 6    | 2    | 3    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 7    | 7    | 7    | 1    |      | 1    | 3    | 3    | 3    | 7    |      | 7    | 7    | 5    | 5    | 5    | 2    | 2    | 2    | 1    |
  |      | 2    | 2    | 2    |      | 2    | 2    | 4    | 4    | 4    |      | 1    | 1    | 1    | 4    | 4    | 4    | 3    | 3    | 3    |
  |      |      | 3    | 3    |      | 5    | 5    | 5    | 6    | 6    |      | 6    | 0    | 0    | 0    | 6    | 6    | 6    | 0    | 0    |

  20 - 2 = 18;

- FIFO

  | 7    | 2    | 3    | 1    | 2    | 5    | 3    | 4    | 6    | 7    | 7    | 1    | 0    | 5    | 4    | 6    | 2    | 3    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 7    | 7    | 7    | 1    |      | 1    |      | 1    | 6    | 6    |      | 6    | 0    | 0    | 0    | 6    | 6    | 6    | 0    | 0    |
  |      | 2    | 2    | 2    |      | 5    |      | 5    | 5    | 7    |      | 7    | 7    | 5    | 5    | 5    | 2    | 2    | 2    | 1    |
  |      |      | 3    | 3    |      | 3    |      | 4    | 4    | 4    |      | 1    | 1    | 1    | 4    | 4    | 4    | 3    | 3    | 3    |

  20 - 3 = 17；

- OPT

  | 7    | 2    | 3    | 1    | 2    | 5    | 3    | 4    | 6    | 7    | 7    | 1    | 0    | 5    | 4    | 6    | 2    | 3    | 0    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 7    | 7    | 7    | 1    |      | 1    |      | 1    | 1    | 1    |      |      | 1    |      | 1    | 1    | 1    | 1    |      |      |
  |      | 2    | 2    | 2    |      | 5    |      | 5    | 5    | 5    |      |      | 5    |      | 4    | 6    | 2    | 3    |      |      |
  |      |      | 3    | 3    |      | 3    |      | 4    | 6    | 7    |      |      | 0    |      | 0    | 0    | 0    | 0    |      |      |

20 - 7 = 13;

### 7.

- 当采用FIFO算法时，若对一个进程未分配它所要求的的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象，即**Belady's anomaly**；
- 当算法满足：*帧数为n的内存页面是帧数为n + 1的内存页面的子集时*，不会发生**Belady's anomaly**。如堆栈算法（LRU, OPT)就绝不会发生此异常。

